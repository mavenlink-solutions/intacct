#!/usr/bin/env ruby

MODELS_TO_GENERATE = %w[project task sotransaction].freeze
LEGACY_ENDPOINTS = %w[create_sotransaction].freeze

ENV["BUNDLER_VERSION"] ||= "1.17.3"
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup"

require "active_support"
require "active_support/core_ext/object"
require "net/http"
require "erb"
require "nokogiri"
require "pry-byebug"
require "rubocop"

MODEL_DIR = File.expand_path("../lib/intacct/models", __dir__).freeze

@template = File.read(File.expand_path("../templates/template.rb.erb", __dir__))

raw_document = Net::HTTP.get(URI("https://raw.githubusercontent.com/Intacct/intacct_dtd/master/v3.0/api.xsd"))
parsed = Nokogiri.XML(raw_document)

def element?(val)
  val.is_a?(Nokogiri::XML::Element)
end

def filtered_children(element)
  element.children.select { |child| element?(child) }
end

def element_required?(element)
  min = element.attributes.values.detect { |attr| attr.name == "minOccurs" }
  return true if min.nil?

  min.value.to_i.positive?
end

def element_name(element)
  element.attributes.values.detect { |attr| attr.name == "ref" || attr.name == "name" }&.value
end

def flatten_children(sequence, required: nil)
  sequence.map do |element|
    element.set_attribute("minOccurs", "0") if required.is_a?(FalseClass)
    next element if element.name == "element"

    filtered_children(element).map do |child|
      if child.name == "element"
        child.set_attribute("minOccurs", "0") if required.is_a?(FalseClass)
        child
      else
        required = required.nil? ? element_required?(element) : required
        flatten_children(child.children, required: required)
      end
    end
  end.flatten
end

class RegisteredTypes
  def self.xml_types
    @xml_types ||= {}
  end
end

class XmlType
  attr_reader :type_name, :sequence

  def self.type?(element)
    type_name(element).present?
  end

  def self.ref?(element)
    ref(element).present?
  end

  def self.type_name(element)
    element.attributes.values.detect { |attr| attr.name == "name" }&.value
  end

  def self.ref(element)
    element.attributes.values.detect { |attr| attr.name == "ref" }&.value
  end

  def self.array?(element)
    val = element.attributes.values.detect { |attr| attr.name == "maxOccurs" }&.value
    val == "unbounded" || val.to_i > 1
  end

  def initialize(element)
    @type_name = self.class.type_name(element)
    @ref_name = self.class.ref(element)
    @required = element_required?(element)
    @array = self.class.array?(element)
    build_sequence(element)
  end

  def required?
    required
  end

  def name
    (type_name || ref_name)
  end

  def xml_name(legacy_endpoint)
    if legacy_endpoint
      name
    else
      name.upcase
    end
  end

  def ref
    RegisteredTypes.xml_types[ref_name]
  end

  def array?
    @array
  end

  def ref?
    ref_name.present?
  end

  def data_type
    if array?
      :array
    elsif ref?
      :ref
    elsif custom_fields?
      :custom_fields
    elsif date?
      :date
    elsif struct?
      :struct
    else
      :string
    end
  end

  def to_ruby(action = "create", required: required?, legacy_endpoint: false)
    case data_type
    when :custom_fields
      custom_field_ruby(action)
    when :date
      format_date(legacy_endpoint, required)
    when :ref
      ref.to_ruby(action, required: required, legacy_endpoint: legacy_endpoint)
    when :array
      wrap_presence_check(<<-RUBY, required)
        Array.wrap(attributes.#{name.pluralize}).each do |attributes|
          #{ref.to_ruby(action, legacy_endpoint: legacy_endpoint)}
        end
      RUBY
    when :struct
      wrap_presence_check(<<-RUBY, required)
        xml.#{xml_name(legacy_endpoint)} do
          #{format_sequence(action, legacy_endpoint)}
        end
      RUBY
    else
      append_presence_check("xml.#{xml_name(legacy_endpoint)} attributes.#{name}", required)
    end
  end

  def legacy_endpoint?
    @type_name.in?(LEGACY_ENDPOINTS)
  end

  private

  def format_date(legacy_endpoint, required)
    if legacy_endpoint
      wrap_presence_check(<<-RUBY, required)
        xml.#{xml_name(legacy_endpoint)} do
          xml.year attributes.#{name}.year
          xml.month attributes.#{name}.month
          xml.day attributes.#{name}.day
        end
      RUBY
    else
      append_presence_check("xml.#{xml_name(legacy_endpoint)} attributes.#{name}.strftime(\"%m/%d/%Y\")", required)
    end
  end

  def format_sequence(action, legacy_endpoint)
    sequence.map { |s| s.to_ruby(action, legacy_endpoint: legacy_endpoint) }.join("\n")
  end

  attr_reader :ref_name, :required

  def custom_field_ruby(action)
    <<-RUBY
      if attributes.customfields.present? || attributes.to_h.except(*#{action.upcase}_KEYS).present?
        xml.customfields do
          if attributes.customfields.present?
            attributes.customfields.presence&.each do |custom_field|
              xml.customfield do
                xml.customfieldname custom_field[:customfieldname]
                xml.customfieldvalue custom_field[:customfieldvalue]
              end
            end
          end

          if attributes.to_h.except(*#{action.upcase}_KEYS).present?
            attributes.to_h.except(*#{action.upcase}_KEYS).each do |name, value|
              xml.customfield do
                xml.customfieldname name
                xml.customfieldvalue value
              end
            end
          end
        end
      end
    RUBY
  end

  def custom_fields?
    name == "customfields"
  end

  def append_presence_check(line, required = required?)
    if required
      line
    else
      "#{line} if attributes.#{name}.present?"
    end
  end

  def wrap_presence_check(multiline, required = required?)
    return multiline if required

    <<-RUBY
      if attributes.#{name}.present?
        #{multiline}
      end
    RUBY
  end

  def date?
    sequence&.count == 3 && sequence.map(&:name).sort == %w[day month year]
  end

  def struct?
    sequence.present?
  end

  def build_sequence(element)
    complex = filtered_children(element).detect { |child| child.name == "complexType" }
    return unless complex.present?

    return if complex.attributes.values.any? do |child|
                child.name == "mixed" && child.value == "true"
              end

    sequence = filtered_children(complex).detect { |child| child.name == "sequence" }
    return if sequence.blank?

    sequence = filtered_children(sequence)
    @sequence = flatten_children(sequence).map { |child| XmlType.new(child) }
  end
end

filtered_children(parsed.root).map do |child|
  if XmlType.type?(child) || XmlType.ref?(child)
    type = XmlType.new(child)
    RegisteredTypes.xml_types[type.type_name] = type
  end
end.compact

def process_template(object)
  @class_name = object.camelcase
  @create_attributes = RegisteredTypes.xml_types["create_#{object}"].sequence
  @update_attributes = RegisteredTypes.xml_types["update_#{object}"].sequence

  @create_names = @create_attributes.map { |attr| attr.name.to_sym }
  @update_names = @update_attributes.map { |attr| attr.name.to_sym }

  @update_names = "CREATE_KEYS" if (@identical = (@create_names == @update_names))
  @create_legacy_endpoint = RegisteredTypes.xml_types["create_#{object}"].legacy_endpoint?
  @update_legacy_endpoint = RegisteredTypes.xml_types["update_#{object}"].legacy_endpoint?

  File.write(File.join(MODEL_DIR, "#{object}.rb"),
             ERB.new(@template, trim_mode: "-").result)
end

MODELS_TO_GENERATE.each { |object| process_template(object) }

RuboCop::CLI.new.run(["-a", MODEL_DIR])
